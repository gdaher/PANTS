#'Pathway Analysis via NeTwork Smoothing
#'
#'This is the main function of the \code{PANTS} package, which implements the PANTS algorithm
#'of Pathway Analysis (and optionally integration) via NeTwork Smoothing for group contrasts.
#'
#'@param object A matrix-like data object containing log-ratios or log-expression values for a
#'series of samples, with rows corresponding to features and columns to samples.
#'@param phenotypes.v A vector of phenotypes of strings the same length as number of samples in \code{object}.
#'If the vector is named, the names must match the column names of \code{object}.
#'@param contrasts.v A named vector of constrasts. The constrasts must refer to the phenotypes
#'in \code{phenotypes.v}. Their order defines the order they are passed to \code{score_fcn}.
#'@param ker The Laplacian kernel matrix.
#'@param Gmat The feature by pathway inclusion matrix, indicating which features are in which pathways.
#'@param score_fcn A function that transforms the t-statistics from the contrasts.
#'Set to \code{identity} so it is the trivial identity function returning its argument.
#'Default is absolute value. Its input must be a vector of same length as number of elements in \code{contrasts.v}.
#'Its output must be a scalar (i.e. a vector of length one).
#'@param nperm Number of permutations to perform to evaluate significance of pathways.
#'@param smooth.pwy.null One of "kde" for kernel density estimation, "norm" for the normal distribution, or NA for 
#'no smoothing of null pathway statistics.
#'@param smooth.feat.null One of "kde" for kernel density estimation, "norm" for the normal distribution, or NA for 
#'no smoothing of null fature statistics.
#'#'@param ret.null.mats If TRUE, return matrices with null distributions for features and pathways.
#'@param verbose Logical indicating if the permutation number should be output every 100 permutations.
#'@details Scores for features in the kernel but not in the data are assigned a value of zero by default for sparsity.
#'Scores for features and pathways are compared to null scores, which are generated by permuting the phenotypes and 
#'rerunning the algorithm. These null scores can be smoothed using \code{\link{density}} or fit to a known distribution,
#'such as the normal or exponential distribution.
#'@return List of length two, with elements \code{pwy.stats} and \code{feature.stats}, each containing a data frame
#'of statistics.
#'@export

pants <- function(object, phenotypes.v, contrasts.v, ker, Gmat, score_fcn=abs, nperm=10^4, smooth.pwy.null=NA, 
                  smooth.feat.null=NA, ret.null.mats=FALSE, verbose=FALSE){
  stopifnot(length(intersect(rownames(ker), rownames(object)))>0, colnames(ker)==rownames(Gmat),
            colnames(object)==names(phenotypes.v))

  intersect.feats <- intersect(rownames(ker), rownames(object))
  #if features are in object but not kernel, & therefore not in Gmat b/c of exp_kernel(),
  #remove from object
  if (nrow(object)-length(intersect.feats) > 0){
    message(nrow(object)-length(intersect.feats), " features removed from 'object', since not in 'kernel'.")
  }
  object <- object[intersect.feats,]
  
  #reorder kernel st upper rows match object; this makes constructing score.match.mat easier
  non.int.f <- setdiff(rownames(ker), intersect.feats)
  ker <- ker[c(intersect.feats, non.int.f), c(intersect.feats, non.int.f)]
  #also need to reorder Gmat
  Gmat <- Gmat[rownames(ker),]
  
  score.v <- score_features(object=object, phenotypes.v=phenotypes.v, 
                            contrasts.v=contrasts.v, score_fcn=score_fcn)
  
  ##scores matched to features in kernel (impute missing as zero)
  score.match.v <- setNames(rep(0, nrow(ker)), nm=rownames(ker))
  score.match.v[intersect.feats] <- score.v
  
  #feature scores in permutations, 74% dense but later combine with a sparse (empty) matrix
  score.mat <- Matrix(0, nrow=nrow(object), ncol=nperm, dimnames = list(rownames(object), paste0('perm', 1:nperm)))
  for (perm in 1:nperm){
    #must set permuted names to NULL st limma_contrasts doesn't complain thay they clash with colnames(object)
    pheno.tmp <- setNames(phenotypes.v[sample(1:length(phenotypes.v))], nm=NULL)

    score.tmp <- score_features(object=object, phenotypes.v=pheno.tmp, contrasts.v=contrasts.v, score_fcn=score_fcn)
    score.mat[, perm] <- score.tmp
    if (verbose){
      if (perm %% 100 == 0) cat("permutation", perm, "\n")
    }
  }

  ##construct score.match.mat to match ker by imputing 0 as missing values, but this makes >200 pwys have pv=0
  #need to use 0 to impute for NAs for sparsity, it's also ~25% of null score
  #score.match.mat <- Matrix(0, nrow=nrow(ker), ncol=ncol(score.mat), dimnames=list(rownames(ker), colnames(score.mat)))
  # score.match.mat <- sparseMatrix(dimnames=list(rownames(ker), colnames(score.mat)))
  #score.match.mat[intersect.feats,] <- score.mat[intersect.feats,]
  score.match.mat <- rbind(score.mat, Matrix(0, nrow=length(non.int.f), ncol=ncol(score.mat), 
                                             dimnames=list(non.int.f, colnames(score.mat))))

  stopifnot(rownames(score.mat)==names(score.tmp), rownames(score.mat)==names(score.v), 
            rownames(score.mat)==intersect.feats, rownames(score.match.mat)==rownames(ker), 
            rownames(ker)==rownames(Gmat))
  
  ##feature p-values (for plotting)
  #features in object & in kernel
  feature.stats <- data.frame(score = score.v, matrix(NA, nrow=length(intersect.feats), ncol=2,
dimnames=list(intersect.feats, c("pval", "FDR"))))
  if (!is.na(smooth.feat.null)){
    feature.stats[,"pval"] <- apply(cbind(score.v, score.mat), MARGIN=1, FUN=function(v){
      p_smooth_ecdf(eval.point=v[1], scores=v[-1], lower.tail=FALSE, smooth.fam=smooth.feat.null)
    })
  } else {
    #need to coerce score.mat to matrix to prevent rowSums error
    feature.stats[,"pval"] <- (rowSums(score.v < as.matrix(score.mat))+0.5*rowSums(score.v == as.matrix(score.mat))+1)/(nperm+1)
  }
  feature.stats[,"FDR"] <- p.adjust(feature.stats[,"pval"], method="BH")

  ##need to compare to pwys, sometimes runs out of memory
  pwy.v <- (score.match.v %*% ker %*% Gmat)[1,]
  pwy.mat <- as.matrix(Matrix::t(Matrix::crossprod(score.match.mat, ker) %*% Gmat))

  #add one to numerator and denominator to avoid p-values of zero, which aren't correct
  if (!is.na(smooth.pwy.null)){
    pwy.pv <- apply(cbind(pwy.v, pwy.mat), MARGIN=1, FUN=function(v){
      p_smooth_ecdf(eval.point=v[1], scores=v[-1], lower.tail=FALSE, smooth.fam=smooth.pwy.null)
    })
  } else {
    pwy.pv <- (rowSums(pwy.v<pwy.mat)+0.5*rowSums(pwy.v==pwy.mat)+1)/(nperm+1)
  }
  pwy.qv <- p.adjust(pwy.pv, method='BH')
  nfeats.per.pwy <- Matrix::colSums(Gmat!=0)
  pwy.stats <- data.frame(score=pwy.v/nfeats.per.pwy, nfeatures=nfeats.per.pwy, pval=pwy.pv, FDR=pwy.qv)
  pwy.stats <- pwy.stats[order(pwy.stats$pval, -pwy.stats$score),]

  res <- list(pwy.stats=pwy.stats, feature.stats=feature.stats)
  if (ret.null.mats){
    res$null.feature.mat <- score.mat
    res$null.pwy.mat <- pwy.mat
  }
  return(res)
}