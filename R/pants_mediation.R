#' Pathway Analysis via NeTwork Smoothing using mediation
#' 
#' PANTS algorithm for mediation pathway analysis (and optionally integration) via network smoothing
#' 
#' @param object A matrix-like data object containing log-ratios or log-expression values for a
#' series of samples, with rows corresponding to features and columns to samples.
#' @param exposure.v A numeric or character vector of exposures the same length as number of samples in \code{object}.
#' If the vector is named, the names must match the column names of \code{object}.
#' @param phenotype.v A vector of numeric phenotypes the same length as number of samples in \code{object}. If the 
#' vector is named, the names must match the column names of \code{object}.
#' @param ker The Laplacian kernel matrix.
#' @param Gmat The feature by pathway inclusion matrix, indicating which features are in which pathways.
#' @param nperm Number of permutations to perform to evaluate significance of pathways.
#' @param ret.null.mats If TRUE, return matrices with null distributions for features and pathways.
#' @param verbose Logical indicating if the permutation number should be output every 500 permutations.
#' @details Scores for features in the kernel but not in the data are assigned a z-score of zero by default for sparsity.
#' Scores for features and pathways are compared to null scores, which are generated by permuting the columns of 
#' \code{object} and rerunning the algorithm.
#' @return List of length at least two, with elements \code{pwy.stats} and \code{feature.stats}, each containing a data frame
#' of statistics.
#' @export

pants_mediation <- function(object, exposure.v, phenotype.v, ker, Gmat, nperm=10^4, ret.null.mats=FALSE, verbose=TRUE){
  stopifnot(length(intersect(rownames(ker), rownames(object)))>0, any(rownames(Gmat) %in% colnames(ker)), 
            ncol(object)==length(phenotype.v), ncol(object)==length(exposure.v), colnames(object)==names(phenotype.v), 
            colnames(object)==names(exposure.v))
  
  lmed <- limma_mediation(E=exposure.v, M=object, Y=phenotype.v)
  #transform to one-sided z-score
  score.v <- qnorm(p=lmed[rownames(object), "comb.p"], lower.tail = FALSE)
  
  #feature scores in permutations, 74% dense but later combine with a sparse (empty) matrix
  score.mat <- Matrix(0, nrow=nrow(object), ncol=nperm, dimnames = list(rownames(object), paste0('perm', 1:nperm)))
  for (perm in 1:nperm){
    #must set permuted names to NULL st limma_contrasts doesn't complain thay they clash with colnames(object)
    object.tmp <- object[,sample(1:ncol(object))]
    #to avoid names error in stopifnot
    colnames(object.tmp) <- colnames(object)
    
    lmed.tmp <- limma_mediation(E=exposure.v, M=object.tmp, Y=phenotype.v)
    score.mat[,perm] <- qnorm(p=lmed.tmp[rownames(object), "comb.p"], lower.tail = FALSE)
    if (verbose){
      if (perm %% 500 == 0) cat("permutation", perm, "\n")
    }
  }
  
  mm <- match_mats(score.mat = cbind(v=score.v, score.mat), ker=ker, Gmat=Gmat)
  #1st column contains non-permuted scores
  score.mat <- mm$score.mat[,-1]; score.v <- mm$score.mat[,1]; ker <- mm$ker; Gmat <- mm$Gmat
  rm(mm) #to save memory
  
  ##feature p-values (for plotting)
  #features in object & in kernel
  feature.stats <- data.frame(score = score.v, matrix(NA, nrow=length(score.v), ncol=3,
                                                      dimnames=list(rownames(score.mat), c("z", "pval", "FDR"))))
  #need to coerce score.mat to matrix to prevent rowSums error
  feature.stats[,c("z", "pval")] <- p_ecdf(eval=score.v, score.mat = as.matrix(score.mat), alternative = "greater")
  feature.stats[,"FDR"] <- p.adjust(feature.stats[,"pval"], method="BH")
  
  ##need to compare to pwys, sometimes runs out of memory
  pwy.v <- (score.v %*% ker %*% Gmat)[1,]
  pwy.mat <- as.matrix(Matrix::t(Matrix::crossprod(score.mat, ker) %*% Gmat))
  
  nfeats.per.pwy <- Matrix::colSums(Gmat!=0)
  pwy.stats <- data.frame(nfeatures=nfeats.per.pwy, feat.score.avg=pwy.v/nfeats.per.pwy, z=NA, pval=NA)
  rownames(pwy.stats) <- colnames(Gmat)
  pwy.stats[,c("z", "pval")] <- p_ecdf(eval.v=pwy.v, scores.mat=pwy.mat, alternative = "greater")
  pwy.stats$FDR <- p.adjust(pwy.stats$pval, method='BH')
  pwy.stats <- pwy.stats[order(pwy.stats$pval, -abs(pwy.stats$feat.score.avg)),]
  
  res <- list(pwy.stats=pwy.stats, feature.stats=feature.stats)
  if (ret.null.mats){
    res$null.feature.mat <- score.mat
    res$null.pwy.mat <- pwy.mat
  }
  return(res)
}