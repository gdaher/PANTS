#'Pathway Analysis via NeTwork Smoothing
#'
#'This is the main function of the \code{PANTS} package, which implements the PANTS algorithm
#'of Pathway Analysis (and optionally integration) via NeTwork Smoothing for group contrasts.
#'
#'@param object A matrix-like data object containing log-ratios or log-expression values for a
#'series of samples, with rows corresponding to features and columns to samples.
#'@param phenotypes.v A vector of phenotypes of strings the same length as number of samples in \code{object}.
#'If the vector is named, the names must match the column names of \code{object}.
#'@param contrasts.v A named vector of constrasts. The constrasts must refer to the phenotypes
#'in \code{phenotypes.v}. Their order defines the order they are passed to \code{score_fcn}.
#'@param ker The Laplacian kernel matrix.
#'@param Gmat The feature by pathway inclusion matrix, indicating which features are in which pathways.
#'@param score_fcn A function that transforms the t-statistics from the contrasts.
#'Set to \code{identity} so it is the trivial identity function returning its argument.
#'Default is absolute value. Its input must be a vector of same length as number of elements in \code{contrasts.v}.
#'Its output must be a scalar (i.e. a vector of length one).
#'@param nperm Number of permutations to perform to evaluate significance of pathways.
#'@param smooth.null One of "kde" for kernel density estimation, "norm" for the normal distribution, "exp" for
#'exponential distribution, or NA for no smoothing of null feature and pathway statistics.
#'@param ret.null.mats If TRUE, return matrices with null distributions for features and pathways.
#'@param verbose Logical indicating if the permutation number should be output every 100 permutations.
#'@details Scores for features in the kernel but not in the data are assigned a value of zero by default for sparsity.
#'Scores for features and pathways are compared to null scores, which are generated by permuting the phenotypes and 
#'rerunning the algorithm. These null scores can be smoothed using \link{\code{density}} or fit to a known distribution,
#'such as the normal or exponential distribution.
#'@return List of length two, with elements \code{pwy.stats} and \code{feature.stats}, each containing a data frame
#'of statistics.
#'@export

pants <- function(object, phenotypes.v, contrasts.v, ker, Gmat, score_fcn=abs, nperm=10^4, smooth.null=NA, 
                  ret.null.mats=FALSE, verbose=FALSE){
  stopifnot(length(intersect(rownames(ker), rownames(object)))>0, colnames(ker)==rownames(Gmat),
            colnames(object)==names(phenotypes.v))

  score.v <- score_features(object=object, phenotypes.v=phenotypes.v, contrasts.v=contrasts.v, score_fcn=score_fcn)

  ##scores matched to features in kernel (impute missing as zero)
  score.match <- setNames(rep(0, nrow(ker)), nm=rownames(ker))
  intersect.feats <- intersect(rownames(ker), names(score.v))
  score.match[intersect.feats] <- score.v[intersect.feats]

  pwy.mat <- matrix(0, nrow=ncol(Gmat), ncol=nperm, dimnames = list(colnames(Gmat), paste0('perm', 1:nperm)))
  #feature scores in permutations
  score.mat <- matrix(NA, nrow=nrow(object), ncol=nperm, dimnames = list(rownames(object), paste0('perm', 1:nperm)))
  for (perm in 1:nperm){
    #must set permuted names to NULL st limma_contrasts doesn't complain thay they clash with colnames(object)
    pheno.tmp <- phenotypes.v[sample(1:length(phenotypes.v))]
    names(pheno.tmp) <- NULL

    score.tmp <- score_features(object=object, phenotypes.v=pheno.tmp, contrasts.v=contrasts.v, score_fcn=score_fcn)
    score.mat[names(score.tmp), perm] <- score.tmp
    if (verbose){
      if (perm %% 100 == 0) cat("permutation", perm, "\n")
    }
  }

  ##construct score.match.mat to match ker by imputing 0 as missing values, but this makes >200 pwys have pv=0
  #need to use 0 to impute for NAs for sparsity, it's also ~25% of null score
  score.match.mat <- Matrix(0, nrow=nrow(ker), ncol=ncol(score.mat), dimnames=list(rownames(ker), colnames(score.mat)))
  score.match.mat[intersect.feats,] <- score.mat[intersect.feats,]

  ##feature p-values (for plotting)
  #features in object & in kernel
  feature.stats <- data.frame(score = score.v[intersect.feats], matrix(NA, nrow=length(intersect.feats), ncol=2,
dimnames=list(intersect.feats, c("pval", "FDR"))))
  if (!is.na(smooth.null)){
    feature.stats[,"pval"] <- apply(cbind(score.v[intersect.feats], score.mat[intersect.feats,]), MARGIN=1, FUN=function(v){
      p_smooth_ecdf(eval.point=v[1], scores=v[-1], lower.tail=FALSE, smooth.fam=smooth.null)
    })
  } else {
    feature.stats[,"pval"] <- (rowSums(score.v < score.mat[names(score.v),])+0.5*rowSums(score.v == score.mat[names(score.v),])+1)/(nperm+1)
  }
  feature.stats[,"FDR"] <- p.adjust(feature.stats[,"pval"], method="BH")

  ##need to compare to pwys, sometimes runs out of memory
  pwy.v <- (score.match %*% ker %*% Gmat)[1,]
  pwy.mat <- as.matrix(Matrix::t(Matrix::crossprod(score.match.mat, ker) %*% Gmat))

  #add one to numerator and denominator to avoid p-values of zero, which aren't correct
  if (!is.na(smooth.null)){
    pwy.pv <- apply(cbind(pwy.v, pwy.mat), MARGIN=1, FUN=function(v){
      p_smooth_ecdf(eval.point=v[1], scores=v[-1], lower.tail=FALSE, smooth.fam=smooth.null)
    })
  } else {
    pwy.pv <- (rowSums(pwy.v<pwy.mat)+0.5*rowSums(pwy.v==pwy.mat)+1)/(nperm+1)
  }
  pwy.qv <- p.adjust(pwy.pv, method='BH')
  nfeats.per.pwy <- Matrix::colSums(gmat.match!=0)
  pwy.stats <- data.frame(score=pwy.v/nfeats.per.pwy, nfeatures=nfeats.per.pwy, pval=pwy.pv, FDR=pwy.qv)
  pwy.stats <- pwy.stats[order(pwy.stats$pval, -pwy.stats$score),]

  res <- list(pwy.stats=pwy.stats, feature.stats=feature.stats)
  if (ret.null.mats){
    res$null.feature.mat <- score.mat[intersect.feats,]
    res$null.pwy.mat <- pwy.mat
  }
  return(res)
}
